#!/usr/bin/env python3
"""
Fixed Button Debug Test using gpiozero
"""

from gpiozero import Button, DigitalInputDevice
import time

def test_button_modes():
    """
    Test different input configurations on GPIO14 - FIXED
    """
    print("Testing GPIO14 with gpiozero...")
    print("=" * 40)
    
    try:
        while True:
            print("\n1. No pull-up/down (floating input):")
            # For floating pins, you MUST specify active_state
            try:
                # Method 1: Specify what "active" means for floating pin
                input_floating = DigitalInputDevice(
                    14, 
                    pull_up=None,
                    active_state=True  # Define active as HIGH voltage
                )
                time.sleep(0.1)
                print(f"   Value: {input_floating.value}")
                input_floating.close()
            except Exception as e:
                print(f"   Error (expected): {e}")
                print("   Note: Floating pins need active_state defined")
            
            # Test 2: With pull-down (active when HIGH)
            print("\n2. With pull-down (active when HIGH):")
            input_pulldown = DigitalInputDevice(14, pull_up=False)
            time.sleep(0.1)
            print(f"   Value: {input_pulldown.value}")
            print(f"   Is active: {input_pulldown.is_active}")
            input_pulldown.close()
            
            # Test 3: With pull-up (active when LOW - inverse logic)
            print("\n3. With pull-up (active when LOW):")
            input_pullup = DigitalInputDevice(14, pull_up=True)
            time.sleep(0.1)
            print(f"   Value: {input_pullup.value}")
            print(f"   Is active: {input_pullup.is_active}")
            input_pullup.close()
            
            # Test 4: Button class (simplified)
            print("\n4. Using Button class:")
            button = Button(14)  # Default: pull_up=True
            print(f"   Is pressed: {button.is_pressed}")
            print(f"   Value: {button.value}")
            print(f"   Pull-up: {button.pull_up}")
            button.close()
            
            print("-" * 40)
            print("Waiting 3 seconds... (Ctrl+C to exit)")
            time.sleep(3)
            
    except KeyboardInterrupt:
        print("\nTest completed!")

def interactive_button_test():
    """
    Interactive button testing - FIXED
    """
    print("\n" + "="*40)
    print("Interactive Button Test")
    print("="*40)
    
    def pressed():
        print(">>> BUTTON PRESSED!")
    
    def released():
        print(">>> BUTTON RELEASED")
    
    def held():
        print(">>> BUTTON HELD (2+ seconds)")
    
    # Create button with event callbacks
    button = Button(
        14,
        pull_up=True,      # Use internal pull-up resistor
        bounce_time=0.05,  # Debounce time in seconds
        hold_time=2        # Time to trigger hold event
    )
    
    # Assign callback functions
    button.when_pressed = pressed
    button.when_released = released
    button.when_held = held
    
    print(f"Button on GPIO{button.pin}")
    print(f"Pull-up enabled: {button.pull_up}")
    print(f"Is pressed: {button.is_pressed}")
    print("\nTest your button:")
    print("- Short press: Should show 'PRESSED' then 'RELEASED'")
    print("- Hold 2+ seconds: Should show 'HELD'")
    print("- Press Ctrl+C to exit")
    print("="*40)
    
    try:
        # Keep program running
        while True:
            time.sleep(0.1)
    except KeyboardInterrupt:
        print("\nExiting...")
    finally:
        button.close()

def simple_button_test():
    """
    SIMPLEST test - just check if button works
    """
    print("\n" + "="*40)
    print("SIMPLE BUTTON TEST")
    print("="*40)
    
    # This is the easiest way - just use Button class
    button = Button(14)  # Uses internal pull-up by default
    
    print("Wiring:")
    print("  Connect one side of button to GPIO14 (Pin 8)")
    print("  Connect other side to GND (Pin 6)")
    print("\nPress the button to test...")
    
    try:
        press_count = 0
        while True:
            if button.is_pressed:
                print(f"✓ Button pressed! ({press_count + 1})")
                press_count += 1
                # Wait for release
                while button.is_pressed:
                    time.sleep(0.01)
            time.sleep(0.01)  # Small delay to reduce CPU usage
            
    except KeyboardInterrupt:
        print(f"\nTotal presses: {press_count}")
        print("Test complete!")

def check_gpiozero_version():
    """
    Check what version of gpiozero you have
    """
    import gpiozero
    print(f"GPIOZero version: {gpiozero.__version__}")
    print("Note: Some attributes changed in version 2.0")
    
    # Show available attributes for Button
    button = Button(14)
    print("\nButton object attributes:")
    attrs = [attr for attr in dir(button) if not attr.startswith('_')]
    print(", ".join(attrs[:10]) + "...")
    button.close()

def main():
    """
    Main function with menu - FIXED
    """
    print("GPIO14 Debug Test - Raspberry Pi OS")
    print("="*50)
    print("RECOMMENDED WIRING:")
    print("  GPIO14 (Pin 8) → Button → GND (Pin 6)")
    print("="*50)
    
    # Check version first
    check_gpiozero_version()
    
    while True:
        print("\nSelect test mode:")
        print("1. Simple button test (RECOMMENDED)")
        print("2. Advanced input mode tests")
        print("3. Interactive button test")
        print("4. Exit")
        
        choice = input("\nEnter choice (1-4): ").strip()
        
        if choice == "1":
            simple_button_test()
        elif choice == "2":
            test_button_modes()
        elif choice == "3":
            interactive_button_test()
        elif choice == "4":
            print("Exiting...")
            break
        else:
            print("Invalid choice. Please enter 1-4.")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"Unexpected error: {e}")
    finally:
        print("Cleanup complete.")
